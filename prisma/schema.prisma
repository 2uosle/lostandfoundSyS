// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String?
  password      String? // Optional for OAuth users
  role          UserRole       @default(STUDENT)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  lostItems     LostItem[]
  foundItems    FoundItem[]
  activityLogs  ActivityLog[]
  notifications Notification[]
}

enum UserRole {
  ADMIN
  STUDENT
}

model LostItem {
  id            String     @id @default(cuid())
  title         String
  description   String
  category      String
  location      String?
  contactInfo   String?
  mobileNumber  String?
  lostDate      DateTime
  status        ItemStatus @default(PENDING)
  imageUrl      String?
  reportedBy    User?      @relation(fields: [userId], references: [id])
  userId        String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  matchedWith   FoundItem? @relation("ItemMatch", fields: [matchedItemId], references: [id])
  matchedItemId String?    @unique

  @@index([category, status])
  @@index([status, createdAt])
  @@index([userId])
}

model FoundItem {
  id                      String     @id @default(cuid())
  title                   String
  description             String
  category                String
  location                String
  contactInfo             String?
  foundDate               DateTime
  status                  ItemStatus @default(PENDING)
  imageUrl                String?
  reportedBy              User?      @relation(fields: [userId], references: [id])
  userId                  String?
  // Student who turned in the item to OSAS
  turnedInByName          String?
  turnedInByStudentNumber String?
  turnedInByContact       String?
  turnedInByDepartment    String?
  createdAt               DateTime   @default(now())
  updatedAt               DateTime   @updatedAt
  matchedItem             LostItem?  @relation("ItemMatch")

  @@index([category, status])
  @@index([status, createdAt])
  @@index([userId])
}

enum ItemStatus {
  PENDING
  MATCHED
  CLAIMED
  ARCHIVED
  RESOLVED
  DONATED
  DISPOSED
}

model ActivityLog {
  id          String      @id @default(cuid())
  action      AdminAction
  itemType    String // 'LOST' or 'FOUND'
  itemId      String
  itemTitle   String // Store title for reference even if item is deleted
  performedBy User        @relation(fields: [userId], references: [id])
  userId      String
  details     String? // JSON string with additional info (matched item, reason, etc.)
  createdAt   DateTime    @default(now())

  @@index([action, createdAt])
  @@index([itemType, itemId])
  @@index([userId])
  @@index([createdAt])
}

enum AdminAction {
  MATCH
  CLAIM
  ARCHIVE
  DELETE
  RESTORE
  RESOLVE
  DONATE
  DISPOSE
  HANDOFF_START
  HANDOFF_COMPLETE
  HANDOFF_RESET
}

model Notification {
  id        String           @id @default(cuid())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      NotificationType
  title     String
  message   String
  itemId    String? // Reference to the item (lost or found)
  itemType  String? // 'LOST' or 'FOUND'
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@index([userId, read])
  @@index([createdAt])
}

enum NotificationType {
  ITEM_MATCHED
  ITEM_CLAIMED
  ITEM_RESOLVED
  ITEM_REPORTED
  MATCH_FOUND
}

enum HandoffStatus {
  ACTIVE
  COMPLETED
  EXPIRED
  LOCKED
}

// Handoff session for 2-way mutual verification (owner and admin)
// The finder has already given the item to admin, so only owner needs to verify
model HandoffSession {
  id                 String        @id @default(cuid())
  lostItemId         String
  foundItemId        String
  ownerUserId        String // Person who lost the item
  finderUserId       String // Person who found it (for reference only)
  ownerCode          String // Code shown only to owner
  adminCode          String // Code shown only to admin
  // Mutual verification: both parties must verify each other
  ownerVerifiedAdmin Boolean       @default(false) // owner entered admin's code
  adminVerifiedOwner Boolean       @default(false) // admin entered owner's code
  ownerAttempts      Int           @default(0)
  adminAttempts      Int           @default(0)
  expiresAt          DateTime
  locked             Boolean       @default(false)
  status             HandoffStatus @default(ACTIVE)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@index([lostItemId])
  @@index([foundItemId])
  @@index([ownerUserId])
  @@index([finderUserId])
  @@index([status, expiresAt])
}

// Distributed rate limiting using database
model RateLimit {
  id        String   @id @default(cuid())
  key       String   // Composite key: "endpoint:identifier" e.g. "login:192.168.1.1"
  count     Int      @default(1)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key])
  @@index([key, expiresAt])
  @@index([expiresAt])
}
